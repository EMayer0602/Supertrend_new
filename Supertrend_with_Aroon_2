# Import necessary libraries
import pandas as pd
import yfinance as yf
from datetime import datetime, timedelta
import numpy as np
import plotly.graph_objects as go
from plotly.subplots import make_subplots
import pdb
# Get date range for last 365 days
end_date = datetime.now()
start_date = end_date - timedelta(days=365)

# Download BTC data
btc = yf.Ticker("BTC-EUR")
btc_data = btc.history(start=start_date, end=end_date)
def debug_with_print(variable):
    print(f"DEBUG: {variable=}, type={type(variable)}")
# Function to calculate technical indicators and trend signals
def calculate_indicators_and_trends(df, period=14):
    df = df.copy()
    df['TR'] = pd.DataFrame([
        df['High'] - df['Low'],
        abs(df['High'] - df['Close'].shift(1)),
        abs(df['Low'] - df['Close'].shift(1))
    ]).max()

    df['UpMove'] = df['High'] - df['High'].shift(1)
    df['DownMove'] = df['Low'].shift(1) - df['Low']

    df['+DM'] = np.where((df['UpMove'] > df['DownMove']) & (df['UpMove'] > 0), df['UpMove'], 0)
    df['-DM'] = np.where((df['DownMove'] > df['UpMove']) & (df['DownMove'] > 0), df['DownMove'], 0)

    df['TR14'] = df['TR'].rolling(window=period).sum()
    df['+DM14'] = df['+DM'].rolling(window=period).sum()
    df['-DM14'] = df['-DM'].rolling(window=period).sum()

    df['+DI'] = 100 * (df['+DM14'] / df['TR14'])
    df['-DI'] = 100 * (df['-DM14'] / df['TR14'])
    df['DX'] = 100 * abs(df['+DI'] - df['-DI']) / (df['+DI'] + df['-DI'])
    df['ADX'] = df['DX'].rolling(window=period).mean()

    # Initialize trend signals
    df['TrendUp'] = 0.0
    df['TrendDown'] = 0.0
    
    # Calculate crossovers and trend signals
    for i in range(1, len(df)):
        prev_plus_di = df['+DI'].iloc[i-1]
        prev_minus_di = df['-DI'].iloc[i-1]
        curr_plus_di = df['+DI'].iloc[i]
        curr_minus_di = df['-DI'].iloc[i]
        
        # Copy previous trends
        df.loc[df.index[i], 'TrendUp'] = df.loc[df.index[i-1], 'TrendUp']
        df.loc[df.index[i], 'TrendDown'] = df.loc[df.index[i-1], 'TrendDown']
        
        # Check for DI+ crossing above DI-
        if prev_plus_di <= prev_minus_di and curr_plus_di > curr_minus_di:
            df.loc[df.index[i], 'TrendUp'] = 1
            df.loc[df.index[i], 'TrendDown'] = 0
        
        # Check for DI- crossing above DI+
        if prev_plus_di >= prev_minus_di and curr_plus_di < curr_minus_di:
            df.loc[df.index[i], 'TrendDown'] = 1
            df.loc[df.index[i], 'TrendUp'] = 0

    columns_to_drop = ['UpMove', 'DownMove', 'TR', '+DM', '-DM', 'TR14', '+DM14', '-DM14', 'DX']
    df = df.drop(columns=columns_to_drop)
    return df

# Process data
btc_data = calculate_indicators_and_trends(btc_data)


# Function to calculate trades with independent handling for long and short positions
def generate_trading_lists(df, initial_capital_long, initial_capital_short):
    long_trades = []
    short_trades = []
    current_position = None
    entry_price = None
    entry_index = None
    entry_date = None
    shares_long = 0
    shares_short = 0
    capital_long = initial_capital_long
    capital_short = initial_capital_short

    # Iterate over the data series
    for i in range(len(df)):
        row = df.iloc[i]

        # Long-Trades: Start and Stop
        if row['TrendUp'] == 1 and current_position != 'Long':  # Start Long
            if current_position == 'Short':  # Close previous Short
                exit_price = row['Close']
                pnl_short = shares_short * (entry_price - exit_price)
                capital_short += pnl_short

                short_trades.append({
                    "Type": "Short",
                    "Buy Date": entry_date,
                    "Sell Date": row.name,
                    "Entry Price": entry_price,
                    "Exit Price": row['Close'],
                    "Shares Short": shares_short,
                    "PnL Short": pnl_short,
                    "Capital Short After Trade": capital_short,
                    "Duration": i - entry_index
                })

            current_position = 'Long'
            entry_price = row['Close']
            entry_index = i
            entry_date = row.name
            shares_long = 1.5 * (capital_long / entry_price)  # Allocate 50% of capital

        if row['TrendUp'] == 0 and current_position == 'Long':  # Stop Long
            pnl_long = shares_long * (row['Close'] - entry_price)
            capital_long += pnl_long

            long_trades.append({
                "Type": "Long",
                "Buy Date": entry_date,
                "Sell Date": row.name,
                "Entry Price": entry_price,
                "Exit Price": row['Close'],
                "Shares Long": shares_long,
                "PnL Long": pnl_long,
                "Capital Long After Trade": capital_long,
                "Duration": i - entry_index
            })
            current_position = None

        # Short-Trades: Start and Stop
        if row['TrendDown'] == 1 and current_position != 'Short':  # Start Short
            if current_position == 'Long':  # Close previous Long
                pnl_long = shares_long * (row['Close'] - entry_price)
                capital_long += pnl_long

                long_trades.append({
                    "Type": "Long",
                    "Buy Date": entry_date,
                    "Sell Date": row.name,
                    "Entry Price": entry_price,
                    "Exit Price": row['Close'],
                    "Shares Long": shares_long,
                    "PnL Long": pnl_long,
                    "Capital Long After Trade": capital_long,
                    "Duration": i - entry_index
                })

            current_position = 'Short'
            entry_price = row['Close']
            entry_index = i
            entry_date = row.name
            shares_short = 1.5 * (capital_short / entry_price)  # Allocate 50% of capital

        if row['TrendDown'] == 0 and current_position == 'Short':  # Stop Short
            pnl_short = shares_short * (entry_price - row['Close'])
            capital_short += pnl_short

            short_trades.append({
                "Type": "Short",
                "Buy Date": entry_date,
                "Sell Date": row.name,
                "Entry Price": entry_price,
                "Exit Price": row['Close'],
                "Shares Short": shares_short,
                "PnL Short": pnl_short,
                "Capital Short After Trade": capital_short,
                "Duration": i - entry_index
            })
            current_position = None

    # Return the resulting trades
    return pd.DataFrame(long_trades), pd.DataFrame(short_trades)


# Function to calculate trade statistics
def calculate_statistics(trades, pnl_column, duration_column):
    if trades.empty:
        return {
            "Total PnL": 0,
            "Average PnL": 0,
            "Average Duration": 0,
            "Number of Trades": 0,
            "Max Drawdown": 0
        }
    total_pnl = trades[pnl_column].sum()
    avg_pnl = trades[pnl_column].mean()
    avg_duration = trades[duration_column].mean()
    num_trades = len(trades)
    max_drawdown = calculate_max_drawdown(trades, pnl_column)
    return {
        "Total PnL": total_pnl,
        "Average PnL": avg_pnl,
        "Average Duration": avg_duration,
        "Number of Trades": num_trades,
        "Max Drawdown": max_drawdown
    }

# Function to calculate max drawdown
def calculate_max_drawdown(trades, pnl_column):
    if trades.empty:
        return 0
    cumulative_pnl = trades[pnl_column].cumsum()
    peak = cumulative_pnl.cummax()
    drawdown = (cumulative_pnl - peak) / peak
    max_drawdown = drawdown.min()
    return abs(max_drawdown)
def calculate_equity_curve(trades, btc_data, trade_type, initial_capital):
    """
    Calculate the equity curve using both Buy Dates and Sell Dates.
    """
    equity_curve = []
    capital = initial_capital
    invested = False  # Track whether a trade is currently open
    entry_price = None  # Track the entry price of the trade
    shares = None  # Track the number of shares purchased
   
    # Ensure btc_data index is in consistent datetime format and remove time zones
    btc_data.index = pd.to_datetime(btc_data.index).tz_localize(None)
    
    # Convert Buy Date and Sell Date to datetime and remove time zones
    trades['Buy Date'] = pd.to_datetime(trades['Buy Date']).dt.tz_localize(None)
    trades['Sell Date'] = pd.to_datetime(trades['Sell Date']).dt.tz_localize(None)
    for date in btc_data.index:
        close = btc_data.loc[date, 'Close']  # Get the closing price for this date
        # Update equity during an open trade
        if invested:
            equity = shares * close  # Value of the trade based on current price
            equity_curve.append(equity)
            print(f"Active Trade on {date}: Close Price = {close}, Equity = {equity}")
        else:
            # Flat equity when not invested
            equity_curve.append(capital)
            print(f"No Active Trade on {date}: Capital = {capital}")

        # Check if a trade starts on this date (Buy Date)
        if date in trades['Buy Date'].values:
            trade = trades[trades['Buy Date'] == date].iloc[0]
            if trade['Type'] == trade_type and not invested:
                # Start a trade
                invested = True
                entry_price = close
                shares = capital / entry_price  # Calculate number of shares
                print(f"Trade Started: {trade_type} on {date}, Entry Price: {entry_price}, Shares: {shares}")

        # Check if a trade ends on this date (Sell Date)
        if date in trades['Sell Date'].values:
            trade = trades[trades['Sell Date'] == date].iloc[0]
            if trade['Type'] == trade_type and invested:
                # End the trade
                invested = False
                capital = shares * close  # Update capital after selling
                entry_price = None
                shares = None
                print(f"Trade Ended: {trade_type} on {date}, Exit Price: {close}, Capital: {capital}")

    return pd.Series(equity_curve, index=btc_data.index)


initial_capital_long = 100000
initial_capital_short = 100000
# Long Capital Curve
# Generate trades

long_trades, short_trades = generate_trading_lists(btc_data, initial_capital_long=100000, initial_capital_short=100000)
print("Generated Long Trades:")
print(long_trades)
print("Generated Short Trades:")
print(short_trades)

# Calculate equity curves
long_equity_curve = calculate_equity_curve(long_trades, btc_data, trade_type="Long", initial_capital=100000)
short_equity_curve = calculate_equity_curve(short_trades, btc_data, trade_type="Short", initial_capital=100000)

# Calculate trade statistics
long_stats = calculate_statistics(long_trades, pnl_column="PnL Long", duration_column="Duration")
short_stats = calculate_statistics(short_trades, pnl_column="PnL Short", duration_column="Duration")

# Calculate equity curves
# Generate trades

# Combine equity curves
combined_equity_curve = long_equity_curve.add(short_equity_curve, fill_value=0)#long_equity_curve = calculate_equity_curve(long_trades, btc_data, trade_type='Long', initial_capital=100000, pnl_column="PnL Long")
#short_equity_curve = calculate_equity_curve(short_trades, btc_data, trade_type='Short', initial_capital=100000, pnl_column="PnL Short")
pd.set_option('display.max_rows', None)
    # Ensure 'Buy Date' is the index and properly normalized
    # Normalize btc_data index

print(long_equity_curve)
print(short_equity_curve)
# Combine equity curves
combined_equity_curve = long_equity_curve.add(short_equity_curve, fill_value=0)
print("\nCombined Equity Curve:")
print(combined_equity_curve)

# Print trade statistics
print("\nLong Trade Statistics:")
print(long_stats)

print("\nShort Trade Statistics:")
print(short_stats)


# Erstelle Subplots mit angepasster Höhe
# Plot results
fig = make_subplots(
    rows=6, cols=1,
    shared_xaxes=True,
    vertical_spacing=0.05,
    subplot_titles=(
        "Long-Trades OHLC", "Long-Trades TrendUp", "Long-Trades Equity Curve",
        "Short-Trades OHLC", "Short-Trades TrendDown", "Short-Trades Equity Curve"
    ),
    row_heights=[0.4, 0.1, 0.4, 0.4, 0.1, 0.4]
)

# Long OHLC
fig.add_trace(
    go.Candlestick(
        x=btc_data.index,
        open=btc_data['Open'],
        high=btc_data['High'],
        low=btc_data['Low'],
        close=btc_data['Close'],
        name="BTC-EUR OHLC (Long)"
    ),
    row=1, col=1
)

# Long TrendUp
fig.add_trace(
    go.Scatter(
        x=btc_data.index,
        y=btc_data['TrendUp'],
        name="TrendUp",
        line=dict(color='green', dash='dot')
    ),
    row=2, col=1
)

# Long Equity Curve
fig.add_trace(
    go.Scatter(
        x=long_equity_curve.index,
        y=long_equity_curve,
        name="Long Equity Curve",
        line=dict(color='blue')
    ),
    row=3, col=1
)

# Short OHLC
fig.add_trace(
    go.Candlestick(
        x=btc_data.index,
        open=btc_data['Open'],
        high=btc_data['High'],
        low=btc_data['Low'],
        close=btc_data['Close'],
        name="BTC-EUR OHLC (Short)"
    ),
    row=4, col=1
)

# Short TrendDown
fig.add_trace(
    go.Scatter(
        x=btc_data.index,
        y=btc_data['TrendDown'],
        name="TrendDown",
        line=dict(color='red', dash='dot')
    ),
    row=5, col=1
)

# Short Equity Curve
fig.add_trace(
    go.Scatter(
        x=short_equity_curve.index,
        y=short_equity_curve,
        name="Short Equity Curve",
        line=dict(color='purple')
    ),
    row=6, col=1
)

# Slider only active on the last chart
fig.update_xaxes(rangeslider_visible=False, row=1, col=1)
fig.update_xaxes(rangeslider_visible=False, row=2, col=1)
fig.update_xaxes(rangeslider_visible=False, row=3, col=1)
fig.update_xaxes(rangeslider_visible=False, row=4, col=1)
fig.update_xaxes(rangeslider_visible=False, row=5, col=1)
fig.update_xaxes(
    rangeslider_visible=True,
    row=6, col=1,
    rangeslider_thickness=0.05
)

# Layout adjustments
fig.update_layout(
    title="Charts with synchronized X-axes and slider in the last chart",
    height=1400,
    hovermode="x unified"
)

# Show the plot
fig.show()
