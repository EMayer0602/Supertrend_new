# Import necessary libraries
import pandas as pd
import yfinance as yf
from datetime import datetime, timedelta
import numpy as np
import plotly.graph_objects as go
from plotly.subplots import make_subplots
import pdb
# Get date range for last 365 days
end_date = datetime.now()
start_date = end_date - timedelta(days=365)

# Download BTC data
btc = yf.Ticker("BTC-EUR")
btc_data = btc.history(start=start_date, end=end_date)
def debug_with_print(variable):
    print(f"DEBUG: {variable=}, type={type(variable)}")
# Function to calculate technical indicators and trend signals
def calculate_indicators_and_trends(df, period=14):
    df = df.copy()
    df['TR'] = pd.DataFrame([
        df['High'] - df['Low'],
        abs(df['High'] - df['Close'].shift(1)),
        abs(df['Low'] - df['Close'].shift(1))
    ]).max()

    df['UpMove'] = df['High'] - df['High'].shift(1)
    df['DownMove'] = df['Low'].shift(1) - df['Low']

    df['+DM'] = np.where((df['UpMove'] > df['DownMove']) & (df['UpMove'] > 0), df['UpMove'], 0)
    df['-DM'] = np.where((df['DownMove'] > df['UpMove']) & (df['DownMove'] > 0), df['DownMove'], 0)

    df['TR14'] = df['TR'].rolling(window=period).sum()
    df['+DM14'] = df['+DM'].rolling(window=period).sum()
    df['-DM14'] = df['-DM'].rolling(window=period).sum()

    df['+DI'] = 100 * (df['+DM14'] / df['TR14'])
    df['-DI'] = 100 * (df['-DM14'] / df['TR14'])
    df['DX'] = 100 * abs(df['+DI'] - df['-DI']) / (df['+DI'] + df['-DI'])
    df['ADX'] = df['DX'].rolling(window=period).mean()

    # Initialize trend signals
    df['TrendUp'] = 0.0
    df['TrendDown'] = 0.0
    
    # Calculate crossovers and trend signals
    for i in range(1, len(df)):
        prev_plus_di = df['+DI'].iloc[i-1]
        prev_minus_di = df['-DI'].iloc[i-1]
        curr_plus_di = df['+DI'].iloc[i]
        curr_minus_di = df['-DI'].iloc[i]
        
        # Copy previous trends
        df.loc[df.index[i], 'TrendUp'] = df.loc[df.index[i-1], 'TrendUp']
        df.loc[df.index[i], 'TrendDown'] = df.loc[df.index[i-1], 'TrendDown']
        
        # Check for DI+ crossing above DI-
        if prev_plus_di <= prev_minus_di and curr_plus_di > curr_minus_di:
            df.loc[df.index[i], 'TrendUp'] = 1
            df.loc[df.index[i], 'TrendDown'] = 0
        
        # Check for DI- crossing above DI+
        if prev_plus_di >= prev_minus_di and curr_plus_di < curr_minus_di:
            df.loc[df.index[i], 'TrendDown'] = 1
            df.loc[df.index[i], 'TrendUp'] = 0

    columns_to_drop = ['UpMove', 'DownMove', 'TR', '+DM', '-DM', 'TR14', '+DM14', '-DM14', 'DX']
    df = df.drop(columns=columns_to_drop)
    return df

# Process data
btc_data = calculate_indicators_and_trends(btc_data)

# Funktion zur Berechnung der Trades
# Funktion zur Berechnung der Handelslisten
#XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
# Function to calculate trades with independent handling for long and short positions
def generate_trading_lists(df, initial_capital_long, initial_capital_short):
    long_trades = []
    short_trades = []
    current_position = None
    entry_price = None
    entry_index = None
    entry_date = None
    shares_long = 0
    shares_short = 0
    capital_long = initial_capital_long
    capital_short = initial_capital_short

    # Iterate over the data series
    for i in range(len(df)):
        row = df.iloc[i]

        # Long-Trades: Start and Stop
        if row['TrendUp'] == 1 and current_position != 'Long':  # Start Long
            if current_position == 'Short':  # Close previous Short
                exit_price = row['Close']
                pnl_short = shares_short * (entry_price - exit_price)
                capital_short += pnl_short

                short_trades.append({
                    "Type": "Short",
                    "Buy Date": entry_date,
                    "Sell Date": row.name,
                    "Entry Price": entry_price,
                    "Exit Price": row['Close'],
                    "Shares Short": shares_short,
                    "PnL Short": pnl_short,
                    "Capital Short After Trade": capital_short,
                    "Duration": i - entry_index
                })

            current_position = 'Long'
            entry_price = row['Close']
            entry_index = i
            entry_date = row.name
            shares_long = 0.5 * (capital_long / entry_price)  # Allocate 50% of capital

        if row['TrendUp'] == 0 and current_position == 'Long':  # Stop Long
            pnl_long = shares_long * (row['Close'] - entry_price)
            capital_long += pnl_long

            long_trades.append({
                "Type": "Long",
                "Buy Date": entry_date,
                "Sell Date": row.name,
                "Entry Price": entry_price,
                "Exit Price": row['Close'],
                "Shares Long": shares_long,
                "PnL Long": pnl_long,
                "Capital Long After Trade": capital_long,
                "Duration": i - entry_index
            })
            current_position = None

        # Short-Trades: Start and Stop
        if row['TrendDown'] == 1 and current_position != 'Short':  # Start Short
            if current_position == 'Long':  # Close previous Long
                pnl_long = shares_long * (row['Close'] - entry_price)
                capital_long += pnl_long

                long_trades.append({
                    "Type": "Long",
                    "Buy Date": entry_date,
                    "Sell Date": row.name,
                    "Entry Price": entry_price,
                    "Exit Price": row['Close'],
                    "Shares Long": shares_long,
                    "PnL Long": pnl_long,
                    "Capital Long After Trade": capital_long,
                    "Duration": i - entry_index
                })

            current_position = 'Short'
            entry_price = row['Close']
            entry_index = i
            entry_date = row.name
            shares_short = 0.5 * (capital_short / entry_price)  # Allocate 50% of capital

        if row['TrendDown'] == 0 and current_position == 'Short':  # Stop Short
            pnl_short = shares_short * (entry_price - row['Close'])
            capital_short += pnl_short

            short_trades.append({
                "Type": "Short",
                "Buy Date": entry_date,
                "Sell Date": row.name,
                "Entry Price": entry_price,
                "Exit Price": row['Close'],
                "Shares Short": shares_short,
                "PnL Short": pnl_short,
                "Capital Short After Trade": capital_short,
                "Duration": i - entry_index
            })
            current_position = None

    # Return the resulting trades
    return pd.DataFrame(long_trades), pd.DataFrame(short_trades)

# Function to calculate trade statistics
def calculate_statistics(trades, pnl_column, duration_column):
    if trades.empty:
        return {
            "Total PnL": 0,
            "Average PnL": 0,
            "Average Duration": 0,
            "Number of Trades": 0,
            "Max Drawdown": 0
        }
    total_pnl = trades[pnl_column].sum()
    avg_pnl = trades[pnl_column].mean()
    avg_duration = trades[duration_column].mean()
    num_trades = len(trades)
    max_drawdown = calculate_max_drawdown(trades, pnl_column)
    return {
        "Total PnL": total_pnl,
        "Average PnL": avg_pnl,
        "Average Duration": avg_duration,
        "Number of Trades": num_trades,
        "Max Drawdown": max_drawdown
    }

# Function to calculate max drawdown
def calculate_max_drawdown(trades, pnl_column):
    if trades.empty:
        return 0
    cumulative_pnl = trades[pnl_column].cumsum()
    peak = cumulative_pnl.cummax()
    drawdown = (cumulative_pnl - peak) / peak
    max_drawdown = drawdown.min()
    return abs(max_drawdown)

# Function to calculate equity curve
def calculate_equity_curve(trades, pnl_column, initial_capital):
    equity_curve = [initial_capital]
    for pnl in trades[pnl_column]:
        equity_curve.append(equity_curve[-1] + pnl)
    return pd.Series(equity_curve)

# Initialize capital
initial_capital_long = 100000
initial_capital_short = 100000

# Generate trades
long_trades, short_trades = generate_trading_lists(btc_data, initial_capital_long, initial_capital_short)

# Calculate trade statistics
long_stats = calculate_statistics(long_trades, pnl_column="PnL Long", duration_column="Duration")
short_stats = calculate_statistics(short_trades, pnl_column="PnL Short", duration_column="Duration")

# Calculate equity curves
long_equity_curve = calculate_equity_curve(long_trades, pnl_column="PnL Long", initial_capital=initial_capital_long)
short_equity_curve = calculate_equity_curve(short_trades, pnl_column="PnL Short", initial_capital=initial_capital_short)

# Combine equity curves
combined_equity_curve = long_equity_curve.add(short_equity_curve, fill_value=0)

# Print trade statistics
print("\nLong Trade Statistics:")
print(long_stats)

print("\nShort Trade Statistics:")
print(short_stats)

print("\nCombined Equity Curve:")
print(combined_equity_curve)

# Erstelle Subplots mit angepasster Höhe
fig = make_subplots(
    rows=6, cols=1,
    shared_xaxes=True,  # Synchronisiere X-Achsen automatisch
    vertical_spacing=0.05,
    subplot_titles=(
        "Long-Trades OHLC", "Long-Trades TrendUp", "Long-Trades Kapitalverlauf",
        "Short-Trades OHLC", "Short-Trades TrendDown", "Short-Trades Kapitalverlauf"
    ),
    row_heights=[0.4, 0.1, 0.4, 0.4, 0.1, 0.4]  # Größenanpassungen: OHLC & Kapital doppelt so groß
)

# Long OHLC
fig.add_trace(
    go.Candlestick(
        x=btc_data.index,
        open=btc_data['Open'],
        high=btc_data['High'],
        low=btc_data['Low'],
        close=btc_data['Close'],
        name="BTC-EUR OHLC (Long)"
    ),
    row=1, col=1
)

# Long TrendUp
fig.add_trace(
    go.Scatter(
        x=btc_data.index,
        y=btc_data['TrendUp'],
        name="TrendUp",
        line=dict(color='green', dash='dot')
    ),
    row=2, col=1
)

# Long Kapitalverlauf
fig.add_trace(
    go.Scatter(
        x=long_equity_curve.index,
        y=long_equity_curve,
        name="Long Equity Curve",
        line=dict(color='blue')
    ),
    row=3, col=1
)

# Short OHLC
fig.add_trace(
    go.Candlestick(
        x=btc_data.index,
        open=btc_data['Open'],
        high=btc_data['High'],
        low=btc_data['Low'],
        close=btc_data['Close'],
        name="BTC-EUR OHLC (Short)"
    ),
    row=4, col=1
)

# Short TrendDown
fig.add_trace(
    go.Scatter(
        x=btc_data.index,
        y=btc_data['TrendDown'],
        name="TrendDown",
        line=dict(color='red', dash='dot')
    ),
    row=5, col=1
)

# Short Kapitalverlauf (Slider aktiv)
fig.add_trace(
    go.Scatter(
        x=short_equity_curve.index,
        y=short_equity_curve,
        name="Short Equity Curve",
        line=dict(color='purple')
    ),
    row=6, col=1
)

# Slider nur im letzten Chart aktiv
fig.update_xaxes(rangeslider_visible=False, row=1, col=1)
fig.update_xaxes(rangeslider_visible=False, row=2, col=1)
fig.update_xaxes(rangeslider_visible=False, row=3, col=1)
fig.update_xaxes(rangeslider_visible=False, row=4, col=1)
fig.update_xaxes(rangeslider_visible=False, row=5, col=1)
fig.update_xaxes(
    rangeslider_visible=True,  # Slider hier aktiv
    row=6, col=1,
    rangeslider_thickness=0.05  # Minimaler Slider
)

# Layout anpassen
fig.update_layout(
    title="Charts mit synchronisierten X-Achsen und Slider im letzten Diagramm",
    height=1400,  # Gesamthöhe
    hovermode="x unified"
)

# Anzeigen
fig.show()
